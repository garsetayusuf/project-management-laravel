# Project Management API

> A production-ready RESTful API built with Laravel 12 featuring custom JWT authentication, project & task management, and comprehensive test coverage.

**Tech Stack:** PHP 8.2+ | Laravel 12 | PostgreSQL | JWT | Pest PHP | Swagger

---

## Table of Contents

- [Features](#features)
- [Prerequisites](#prerequisites)
- [Installation & Setup](#installation--setup)
- [Environment Configuration](#environment-configuration)
- [API Response Structure](#api-response-structure)
- [Database Schema](#database-schema)
- [Authentication Flow](#authentication-flow)
- [Testing](#testing)
- [Development Commands](#development-commands)
  - [Database Management](#database-management)
  - [API Documentation (Swagger/OpenAPI)](#api-documentation-swaggeropenapi)
- [Scheduled Tasks](#scheduled-tasks)
- [Troubleshooting](#troubleshooting)

---

## Features

### Core Features

- **Custom JWT Authentication System**
  - Short-lived access tokens (15 minutes default)
  - Long-lived refresh tokens (30 days default)
  - Refresh token rotation on each refresh
  - Token blacklisting for revoked access tokens
  - Device tracking (device name, IP address)
  - Multi-device session management
  - Logout from all devices functionality

- **Project Management**
  - Create, read, update, delete projects
  - User-specific project isolation
  - Task count aggregation
  - Policy-based authorization

- **Task Management**
  - Full CRUD operations on tasks
  - Task filtering by project_id, status, priority
  - Status tracking: pending, in_progress, done
  - Priority levels: low, medium, high, urgent
  - Due date management
  - Relationship with projects and users

- **Security & Authorization**
  - Policy-based authorization (ProjectPolicy, TaskPolicy)
  - Users can only access their own resources
  - JWT middleware for protected routes
  - Token blacklist system
  - Secure password hashing (Bcrypt, 12 rounds)

- **Testing & Documentation**
  - Swagger/OpenAPI documentation
  - Feature and integration test coverage
  - Authorization policy tests
  - Standardized API response structure with error codes

- **API Response Standardization**
  - Consistent JSON response format across all endpoints
  - Unified error handling with validation error details
  - Proper HTTP status codes (200, 201, 401, 403, 404, 422)
  - camelCase field naming convention

---

## Prerequisites

Before you begin, ensure you have the following installed:

- **PHP 8.2** or higher
- **Composer** (for PHP dependencies)
- **PostgreSQL 14** or higher
- **Git** (for version control)

---

## Installation & Setup

### Step 1: Clone the Repository

```bash
git clone <repository-url>
cd project-managemenet-laravel
```

### Step 2: Install Dependencies

```bash
composer install
```

### Step 3: Setup Environment File

```bash
cp .env.example .env
php artisan key:generate
```

### Step 4: Configure Database

Edit `.env` and set your PostgreSQL credentials:

```env
DB_CONNECTION=pgsql
DB_HOST=127.0.0.1
DB_PORT=5432
DB_DATABASE=project_managemenet_laravel
DB_USERNAME=postgres
DB_PASSWORD=your_password
```

**Create the database** (if it doesn't exist):

```bash
createdb project_managemenet_laravel
```

### Step 5: Run Database Migrations

```bash
php artisan migrate
```

### Step 6: (Optional) Seed the Database

```bash
php artisan db:seed
```

See [Database Management](#database-management) section for more seeding options and details.

### Step 7: (Optional) Generate API Documentation

Generate Swagger/OpenAPI documentation for the API:

```bash
php artisan l5-swagger:generate
```

After generation, the API documentation will be available at:

```
http://localhost:9000/api/documentation
```

### Step 8: Start the Development Server

```bash
composer run dev
```

The API will be available at: `http://localhost:9000`

---

## Environment Configuration

### Application Settings

```env
APP_NAME=Laravel
APP_ENV=local              # Environment: local, staging, production
APP_KEY=        # Generated by key:generate
APP_DEBUG=false            # Set to true for development, false for production
APP_PORT=9000              # Server port
APP_URL=http://localhost:9000
```

### Database Configuration

```env
DB_CONNECTION=pgsql       # PostgreSQL connection
DB_HOST=127.0.0.1         # Database host
DB_PORT=5432              # Database port
DB_DATABASE=project_managemenet_laravel # Database name
DB_USERNAME=postgres      # Database username
DB_PASSWORD=postgres      # Database password
```

### JWT Configuration

These control the JWT authentication behavior:

```env
JWT_SECRET=                    # Secret key for signing tokens (auto-generated)
JWT_ACCESS_TTL=15              # Access token lifetime in minutes
JWT_REFRESH_TTL=43200          # Refresh token lifetime in minutes (30 days)
JWT_ALGO=HS256                 # Signing algorithm
JWT_ROTATE_REFRESH_TOKENS=true # Enable token rotation for security
JWT_PRUNE_REVOKED_AFTER_DAYS=30 # Days to keep revoked tokens
```

### Logging Configuration

```env
LOG_CHANNEL=stack
LOG_STACK=single
LOG_LEVEL=debug
```

---

## API Response Structure

All API endpoints return a standardized JSON response format for consistency and predictability.

### Success Response (HTTP 200, 201)

```json
{
  "status": "success",
  "data": {
    "user": {
      "id": 1,
      "name": "John Doe",
      "email": "john@example.com",
      "created_at": "2024-12-09T10:30:00Z",
      "updated_at": "2024-12-09T10:30:00Z"
    },
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "abc123def456ghijklmnop...",
    "projects": [...],
    "tasks": [...]
  },
  "message": "User registered successfully",
  "statusCode": 201
}
```

### Error Response (HTTP 4xx, 5xx)

#### Validation Error (422)

```json
{
  "status": "error",
  "data": {
    "errors": {
      "email": ["The email field is required."],
      "password": ["The password must be at least 8 characters."]
    }
  },
  "message": "Validation failed",
  "error": "ValidationError",
  "statusCode": 422
}
```

#### Authentication Error (401)

```json
{
  "status": "error",
  "data": null,
  "message": "Token missing, invalid, or expired",
  "error": "Unauthorized",
  "statusCode": 401
}
```

#### Authorization Error (403)

```json
{
  "status": "error",
  "data": null,
  "message": "You do not have permission to perform this action",
  "error": "Forbidden",
  "statusCode": 403
}
```

#### Not Found Error (404)

```json
{
  "status": "error",
  "data": null,
  "message": "Resource not found",
  "error": "NotFound",
  "statusCode": 404
}
```

### Response Fields

| Field | Type | Description |
|-------|------|-------------|
| `status` | string | Either `"success"` or `"error"` |
| `data` | object\|null | Response data or validation errors; `null` for error responses without data |
| `message` | string | Human-readable message describing the operation result |
| `error` | string | Error code for programmatic handling (e.g., `"Unauthorized"`, `"ValidationError"`) |
| `statusCode` | integer | HTTP status code (mirrors HTTP header) |

### Data Structure Examples

**Registration/Login Response:**

```json
{
  "accessToken": "JWT token string",
  "refreshToken": "Random token string",
  "user": { user object }
}
```

**Project Listing Response:**

```json
{
  "projects": [
    {
      "id": 1,
      "name": "Project Name",
      "description": "Project description",
      "user_id": 1,
      "tasks_count": 5,
      "created_at": "2024-12-09T10:30:00Z",
      "updated_at": "2024-12-09T10:30:00Z"
    }
  ]
}
```

**Task Listing Response:**

```json
{
  "tasks": [
    {
      "id": 1,
      "title": "Task title",
      "description": "Task description",
      "status": "pending",
      "priority": "high",
      "due_date": "2024-12-31",
      "project_id": 1,
      "user_id": 1,
      "created_at": "2024-12-09T10:30:00Z",
      "updated_at": "2024-12-09T10:30:00Z"
    }
  ]
}
```

### Implementation Details

- All responses use **camelCase** for field names (e.g., `accessToken`, `refreshToken`, `tasksCount`)
- Validation errors are wrapped in `data.errors` object with field names as keys
- Empty responses still include all four fields (status, data, message, statusCode)
- Timestamps are in ISO 8601 format (UTC)

---

## Database Schema

### Entity Relationship Diagram

```
users (1) ─────────── (many) projects
  │                       │
  │                       └─── (many) tasks
  │
  └─────────────────────────── (many) tasks

users
├─ id (PK, UUID)
├─ name
├─ email (UNIQUE)
├─ password
├─ email_verified_at
└─ timestamps

projects
├─ id (PK, auto-increment bigint)
├─ user_id (FK → users.id, UUID)
├─ name
├─ description
└─ timestamps

tasks
├─ id (PK, auto-increment bigint)
├─ project_id (FK → projects.id, bigint)
├─ user_id (FK → users.id, UUID)
├─ title
├─ description
├─ status (enum: pending, in_progress, done)
├─ priority (enum: low, medium, high, urgent)
├─ due_date
└─ timestamps

refresh_tokens
├─ id (PK, UUID)
├─ user_id (FK → users.id, UUID)
├─ token_hash (UNIQUE, SHA-256 hashed)
├─ device_name
├─ ip_address
├─ expires_at
├─ revoked_at
├─ last_used_at
└─ timestamps

token_blacklist
├─ id (PK, UUID)
├─ user_id (FK → users.id, UUID)
├─ token (text, full JWT)
├─ expires_at
└─ timestamps
```

### ID Column Strategy

The application uses a strategic mix of UUID and auto-increment primary keys:

| Table | ID Type | Reason |
|-------|---------|--------|
| **users** | UUID | User identification in distributed systems, privacy, and API exposure safety |
| **projects** | Auto-increment | Sequential IDs for user-facing references and better database indexing performance |
| **tasks** | Auto-increment | Simple, predictable IDs for task management within projects |
| **refresh_tokens** | UUID | Security and uniqueness for token identification |
| **token_blacklist** | UUID | Consistency with token management system |

- **UUID fields** use `CHAR(36)` storage and are suitable for sensitive operations
- **Auto-increment fields** are optimized for performance and are safe within user isolation context
- **Foreign keys** maintain appropriate type relationships (UUID FK → UUID PK, bigint FK → bigint PK)

---

## Authentication Flow

### JWT Token Lifecycle

```
┌─────────────────────────────────────────────────┐
│                                                 │
│  1. User Registration/Login                     │
│     ├─ POST /api/register or /api/login         │
│     └─ Verify credentials                       │
│                                                 │
├─────────────────────────────────────────────────┤
│  2. Receive Tokens                              │
│     ├─ access_token (JWT, 15 minutes)           │
│     └─ refresh_token (random, 30 days)          │
│                                                 │
├─────────────────────────────────────────────────┤
│  3. Make API Requests                           │
│     ├─ Include: Authorization: Bearer {token}   │
│     ├─ Middleware validates JWT signature       │
│     ├─ Middleware checks if expired             │
│     └─ Middleware checks if blacklisted         │
│                                                 │
├─────────────────────────────────────────────────┤
│  4. When Access Token Expires                   │
│     ├─ POST /api/refresh                        │
│     ├─ Send refresh_token                       │
│     ├─ Receive new access_token + refresh_token │
│     └─ Continue making requests                 │
│                                                 │
├─────────────────────────────────────────────────┤
│  5. On Logout                                   │
│     ├─ POST /api/logout                         │
│     ├─ Access token added to blacklist          │
│     ├─ Refresh token marked as revoked          │
│     └─ All old tokens become invalid            │
│                                                 │
└─────────────────────────────────────────────────┘
```

### Token Blacklist System

When a user logs out, their access token is immediately added to the blacklist:

- **Revoked tokens cannot be reused** - Even with valid signature
- **Immediate effect** - No 15-minute grace period
- **Multi-device logout** - Use `POST /api/logout/all` to revoke all devices

---

## Testing

### Running Tests

```bash
# Run all tests
php artisan test

# Run specific test file
php artisan test tests/Feature/AuthTest.php
```

### Test Coverage

- **Authentication Tests** - Registration, login, token refresh
- **Authorization Tests** - Policy-based access control
- **Project Tests** - CRUD operations
- **Task Tests** - CRUD and filtering
- **Token Management** - Blacklisting and refresh token rotation

---

## Development Commands

### Database Management

#### Seeding the Database

**Seed with initial data:**

```bash
php artisan db:seed
```

**Fresh database with seeds (resets all data):**

```bash
php artisan migrate:fresh --seed
```

**Seed without running migrations:**

```bash
php artisan db:seed --force
```

**What gets created when seeding:**

- 1 User with random name and email
- 1 Project belonging to the user
- 2 Tasks with varied statuses (pending, in_progress, done) and priorities (medium, high, urgent)

### Code Formatting

```bash
# Format all code (Laravel Pint)
composer format

# Check formatting without fixing
composer format:check
```

### API Documentation (Swagger/OpenAPI)

#### Generate Swagger Documentation

```bash
php artisan l5-swagger:generate
```

This command scans all controllers for PHPDoc annotations and generates OpenAPI specification files.

**When to regenerate documentation:**

- After adding new API endpoints
- After modifying request/response structures
- After updating authentication requirements
- After changing route parameters

#### Access Swagger UI

Once generated, access the interactive API documentation:

```
http://localhost:9000/api/documentation
```

**Features available in Swagger UI:**

- ✅ View all endpoints and methods
- ✅ See request/response examples
- ✅ Test endpoints directly (try-it-out)
- ✅ View authentication requirements
- ✅ Explore query parameters and filters
- ✅ Review error responses

### Cache Management

```bash
# Clear all caches
php artisan optimize:clear

# Clear configuration cache
php artisan config:clear

# Clear route cache
php artisan route:clear
```

### Token Management

```bash
# Manually prune expired tokens (runs daily automatically)
php artisan tokens:prune

# Prune with custom retention (7 days)
php artisan tokens:prune --days=7
```

---

## Scheduled Tasks

### Scheduler Test

- Run the scheduler once (for testing)

```bash
 php artisan schedule:run
```

- Show all scheduled commands

```bash
 php artisan schedule:list
```

### Automatic Token Cleanup

The application automatically cleans up expired and revoked tokens daily:

```
Time: 1:00 AM every day
Command: php artisan tokens:prune
Retention: 30 days (configurable)
```

### Setup for Production

Add to your server's crontab:

```bash
# Run Laravel scheduler every minute
* * * * * cd /path/to/project && php artisan schedule:run >> /dev/null 2>&1
```

The Laravel scheduler will then execute commands based on their defined schedules.

---

## Troubleshooting

### Common Issues and Solutions

#### 1. "No application encryption key has been specified"

**Error:** `RuntimeException: No application encryption key has been specified.`

**Solution:**

```bash
php artisan key:generate
```

---

#### 2. Database Connection Errors

**Error:** `SQLSTATE[08006]: Connection refused`

**Checklist:**

```bash
# 1. Verify PostgreSQL is running
psql --version

# 2. Check database exists
psql -U postgres -l | grep project_managemenet_laravel

# 3. Create database if missing
createdb project_managemenet_laravel

# 4. Verify .env credentials
cat .env | grep DB_

# 5. Test connection
php artisan tinker
>>> DB::connection()->getPdo()
```

---

#### 3. Migration Errors

**Error:** `SQLSTATE[42P07]: Duplicate table`

**Solution:**

```bash
# Rollback all migrations
php artisan migrate:rollback --step=999

# Re-run migrations
php artisan migrate

# Or for fresh database
php artisan migrate:fresh --seed
```

---

#### 4. "Token has been revoked" After Logout

This is **expected behavior**. The token blacklist system immediately revokes access tokens on logout.

**How to get a new token:**

1. Use refresh token to get new access token: `POST /api/refresh`
2. Or login again: `POST /api/login`

---

#### 5. Tests Failing

**Error:** `SQLSTATE[HY000]: General error: 1 no such table`

**Solution:**

```bash
# Run migrations for test environment
php artisan migrate --env=testing

# Or completely refresh
php artisan migrate:fresh --env=testing --seed
```

---

#### 6. CORS Errors in Browser

**Error:** `Access to XMLHttpRequest... has been blocked by CORS policy`

**Solution:** Verify CORS is configured in `config/cors.php`:

```php
'paths' => ['api/*'],
'allowed_origins' => ['*'],  // or specific domains
'allowed_methods' => ['*'],
```

---

### Debug Mode

Enable debug mode to see detailed error messages:

```env
# In .env
APP_DEBUG=true
```

**⚠️ Warning:** Always set `APP_DEBUG=false` in production!
